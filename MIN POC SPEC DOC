# AFM Minimal Ingestion & Gwyddion POC Pipeline

v1A-120125  
_CROgpt Structured Spec for Manus → Codex Implementation_ (or CoPilot)

---

## 1. Purpose

This document defines a **minimal, 2-day proof-of-concept pipeline** for AFM TIFF ingestion, processing through **Gwyddion**, extraction of basic **modulus / topo statistics**, **particle statistics**, and generation of **grid-structured CSVs + heatmaps**.

This POC intentionally avoids HDF5, USID, or NeXus.  
It uses:

- One **input folder** of hand-selected TIFF files
    
- A set of **Python + Gwyddion** functions
    
- A small family of **per-scan CSVs** and **grid-aggregated CSVs**
    
- Four plotting outputs showing grid-level consistency across each surface
    

You will hand this to **Manus** to produce pseudocode, then Codex to generate runnable Python in a repo.

---

# 2. Input Assumptions

### 2.1 File Layout

User supplies a folder:

`INPUT_ROOT/     <SmartScanFilename1>.tif     <SmartScanFilename2>.tif     ...`

Filnames follow the established SmartScan pattern (SpecimenID, SampleTag, SurfaceID, GridID, LOC_RC, scan area, channel, direction).  
From the filename you extract:

- specimen_id
    
- sample_tag
    
- surface_id
    
- particle_tag
    
- grid_id
    
- row_index
    
- col_index
    
- scan_size_x_um
    
- scan_size_y_um
    
- channel_name_raw
    
- scan_direction
    

### 2.2 Modes

Two operational modes:

1. **PEGDA modulus mode**  
    Processes topography or modulus channels, generates per-scan statistics.
    
2. **Particle statistics mode**  
    Processes topography, detects grains, produces per-scan particle statistics.
    

Optional:  
A **layout template** CSV/JSON defining expected grid cell locations.  
If absent, grid is inferred from `(row_index, col_index)` pairs.

---

# 3. Core Data Structures

### 3.1 `ImageJob`

`file_path file_name specimen_id sample_tag surface_id particle_tag grid_id row_index col_index scan_size_x_um scan_size_y_um channel_name_raw channel_type        # topography | modulus | other scan_direction mode                # pegda_modulus | particle_stats`

### 3.2 `ScanStatsRow` (PEGDA / Topo)

`specimen_id sample_tag surface_id grid_id row_index col_index channel_type flatten_method mask_name n_pixels_total n_pixels_used value_mean value_std value_min value_max scan_size_x_um scan_size_y_um scan_direction source_file_name`

### 3.3 `ParticleStatsRow`

`specimen_id sample_tag surface_id grid_id row_index col_index particle_count_total particle_count_good particle_area_mean particle_area_std good_area_fraction scan_size_x_um scan_size_y_um mask_name source_file_name`

### 3.4 `GridLayout`

`n_rows n_cols valid_cells = [(row_index, col_index), ...]`

---

# 4. Pipeline Function Spec (for Manus → pseudocode)

## 4.1 File Discovery & Metadata

### `discover_input_files(input_root) -> List[ImageJob]`

- Recursively locate TIFFs
    
- Parse metadata per filename
    
- Construct list of `ImageJob` objects
    

### `parse_filename_metadata(file_name) -> dict`

- Extract specimen/sample/surface/grid/row/col/channel/direction
    
- Extract scan-size
    
- Return metadata dict
    

### `classify_channel_type(channel_name_raw) -> str`

Maps `'Z Height'` → `topography`, `'Modulus'` → `modulus`, others → `other`.

---

## 4.2 Gwyddion Processing

### `load_tiff_into_gwyddion(job) -> GwyddionHandle`

Open TIFF inside Gwyddion environment (pygwy or batch mode).

### `preprocess_topography(handle, config) -> PreprocessedHandle`

Fixed operations sequence:

1. Plane leveling
    
2. Line-by-line correction
    
3. Median/Gaussian optional
    
4. Outlier clipping
    

### `generate_mask_from_topography(preprocessed_handle, mask_config) -> MaskArray`

Build mask to remove high spots or invert to isolate particles:

- mask_mode = none | clip_high | clip_low | clip_both
    
- high_sigma, low_sigma thresholds
    

---

## 4.3 PEGDA Modulus / Topo Statistics

### `compute_modulus_stats(preprocessed_handle, mask, job) -> ScanStatsRow`

Calculate masked/unmasked pixel stats:

- mean, std, min, max
    
- n_pixels_total, n_pixels_used
    

### `write_modulus_stats_csv(rows, out_path)`

Append all `ScanStatsRow` entries.

---

## 4.4 Particle Detection & Statistics

### `detect_particles(preprocessed_handle, mask, config) -> ParticleLabelMap`

Use Gwyddion grain analysis:

- thresholding (absolute/relative/sigma)
    
- min/max area
    
- min height
    

### `compute_particle_statistics(label_map, preprocessed_handle, job, config) -> ParticleStatsRow`

Compute:

- particle_count_total
    
- particle_count_good
    
- area stats (mean/std/min/max)
    

### `write_particle_stats_csv(rows, out_path)`

Dump rows to CSV.

---

## 4.5 Grid Aggregation

### `load_layout_template_or_infer(stats_rows, layout_template_path=None) -> GridLayout`

- If template given, load and use
    
- Otherwise infer `(n_rows, n_cols)` from observed row/col pairs
    

### `build_grid_tables(stats_rows, layout, value_field) -> GridTable`

- Reshape into 2D array with NaN for missing cells
    

### `write_grid_table_csv(grid_table, out_path, value_field)`

Write grid matrix to CSV.

---

# 5. Top-Level Entry Functions

## `run_pegda_modulus_poc(input_root, out_dir, channel_type, layout_template_path=None)`

Steps:

1. Discover TIFFs
    
2. Filter by channel_type
    
3. For each job:
    
    - Load TIFF into Gwyddion
        
    - Preprocess
        
    - Generate mask
        
    - Compute stats
        
4. Write `pegda_modulus_stats.csv`
    
5. Load/infer grid layout
    
6. Build grid tables for:
    
    - `value_mean`
        
    - `value_std`
        
7. Output:
    
    - `grid_modulus_mean.csv`
        
    - `grid_modulus_std.csv`
        

---

## `run_particle_stats_poc(input_root, out_dir, layout_template_path=None)`

Steps:

1. Discover TIFFs
    
2. Filter for topography
    
3. Per job:
    
    - Load TIFF
        
    - Preprocess
        
    - Mask
        
    - Detect particles
        
    - Compute particle stats
        
4. Write `particle_stats.csv`
    
5. Infer or load grid layout
    
6. Build grid tables for:
    
    - `particle_count_total` or `particle_count_good`
        
    - `particle_area_std`
        
7. Output:
    
    - `grid_particle_count.csv`
        
    - `grid_particle_area_std.csv`
        

---

## `aggregate_grid_csvs(per_scan_csv_path, out_dir, value_fields)`

1. Load per-scan CSV
    
2. Infer layout
    
3. For each value_field:
    
    - Build grid
        
    - Write CSV
        

---

# 6. Plotting Specification

This defines the four POC plots you’ll generate to show spatial consistency.

Orientation rule:

- `row_index` increases **upwards**
    
- `col_index` increases **rightwards**
    
- Bottom-left cell: `(row=1, col=1)`
    

Missing cells are NaN.

---

## 6.1 Plot M1 — Mean Modulus Grid

**Data:**  
`M_mean[row, col] = value_mean` from modulus rows.

**Spec:**

- 2D heatmap
    
- x = col_index
    
- y = row_index
    
- Colorbar: “Mean modulus [MPa]”
    
- Fixed color limits across sample type
    

**Output:**  
`grid_modulus_mean.png`

---

## 6.2 Plot M2 — Modulus Standard Deviation Grid

**Data:**  
`M_std[row, col] = value_std`

**Spec:**

- 2D heatmap
    
- Same axes
    
- Colorbar: “Std dev modulus [MPa]”
    

**Output:**  
`grid_modulus_std.png`

---

## 6.3 Plot P1 — Particle Count Grid

**Data:**  
`P_count[row, col] = particle_count_good`  
(or total — pick once and be consistent)

**Spec:**

- 2D heatmap
    
- Colorbar: “Particle count per scan”
    

**Output:**  
`grid_particle_count.png`

---

## 6.4 Plot P2 — Particle Spread Grid

**Data:**  
`P_spread[row, col] = particle_area_std`

**Spec:**

- 2D heatmap
    
- Colorbar: “Std dev particle area [µm²]”
    

**Output:**  
`grid_particle_area_std.png`

---

## 6.5 Optional QC

Not part of core POC, but trivial if needed:

- Histogram of modulus per scan
    
- Histogram of particle areas per scan
    

---

# 7. Deliverables

For each run, scripts produce:

### Per-scan CSVs

- `pegda_modulus_stats.csv`
    
- `particle_stats.csv`
    

### Grid CSVs

- `grid_modulus_mean.csv`
    
- `grid_modulus_std.csv`
    
- `grid_particle_count.csv`
    
- `grid_particle_area_std.csv`
    

### Grid Plots

- `grid_modulus_mean.png`
    
- `grid_modulus_std.png`
    
- `grid_particle_count.png`
    
- `grid_particle_area_std.png`
    

---

# 8. Final Notes for Manus & Codex

- This POC is intentionally crude but fully functional.
    
- Manus should produce detailed pseudocode for each function here.
    
- Codex then converts that pseudocode into Python that calls Gwyddion APIs (pygwy) or batch commands.
    
- Use the filename metadata mapping exactly as defined.
    
- Strictly maintain row/col → grid alignment for plotting.
